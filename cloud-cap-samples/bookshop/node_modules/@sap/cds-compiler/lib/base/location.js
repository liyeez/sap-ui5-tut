'use strict';

// This file contains functions related to XSN/CSN-location objects as well
// as for semantic locations

const { analyseCsnPath, traverseQuery } = require('../model/csnRefs');
const { copyPropIfExist } = require('../utils/objectUtils');

/**
 * Create a location with properties `file`, `line` and `col` from argument
 * `start`, and properties `endLine` and `endCol` from argument `end`.
 *
 * @param {XSN.WithLocation} start
 * @param {XSN.WithLocation} end
 * @returns {CSN.Location}
 */
function combinedLocation( start, end ) {
  if (!start)
    return end.location;
  else if (!end)
    return start.location;
  const loc = {
    file: start.location.file,
    line: start.location.line,
    col: start.location.col,
  };
  copyPropIfExist(loc, 'endLine', end.location);
  copyPropIfExist(loc, 'endCol', end.location);
  return loc;
}

/**
 * Create an empty location object with the given file name.
 *
 * @param {string} filename
 * @returns {CSN.Location}
 */
function emptyLocation(filename) {
  return {
    file: filename,
    line: 1,
    col: 1,
    endLine: 1,
    endCol: 1,
  };
}

/**
 * Create an empty location object with the given file name.
 * The end line/column is not set and therefore the location is weak.
 *
 * @param {string} filename
 * @returns {CSN.Location}
 */
function emptyWeakLocation(filename) {
  return {
    file: filename,
    line: 1,
    col: 1,
  };
}

/**
 * Returns a dummy location for built-in definitions.
 *
 * @returns {CSN.Location}
 */
function builtinLocation() {
  return emptyLocation('<built-in>');
}

/**
 * @returns {CSN.Location}
 */
function normalizeLocation( loc ) {
  // TODO: remove function
  return loc;
}

/**
 * Return the source location of the complete dictionary `dict`.  If
 * `extraLocation` is truthy, also consider this location.
 * ASSUMPTION: all entries in the dictionary have a property `location` and
 * `location.file` has always the same value.
 *
 * TODO: remove this function - if we really want to have dictionary locations,
 * set them in the CDL parser, e.g. via a symbol.
 *
 * @param {object} dict
 * @param {CSN.Location} [extraLocation]
 * @returns {CSN.Location}
 */
function dictLocation( dict, extraLocation ) {
  if (!dict)
    return extraLocation;

  if (!Array.isArray(dict))
    dict = Object.getOwnPropertyNames( dict ).map( name => dict[name] );

  /** @type {CSN.Location[]} */
  const locations = [].concat( ...dict.map( _objLocations ) );
  if (extraLocation)
    locations.push( extraLocation );

  const min = locations.reduce( (a, b) => (a.line < b.line || (a.line === b.line && a.col < b.col) ? a : b) );
  const max = locations.reduce( (a, b) => {
    const lineA = (a.endLine || a.line);
    const lineB = (b.endLine || b.line);
    return (lineA > lineB || (lineA === lineB && (a.endCol || a.col) > (b.endCol || b.col)) ? a : b);
  });
  return {
    file: min.file,
    line: min.line,
    col: min.col,
    endLine: max.endLine,
    endCol: max.endCol,
  };
}
dictLocation.end = (dict) => {
  const loc = dictLocation( dict );
  return loc && { file: loc.file, line: loc.endLine, col: loc.endCol };
};

function _objLocations( obj ) {
  return Array.isArray(obj) ? obj.map( o => o.location ) : [ obj.location ];
}


function constructSemanticLocationFromCsnPath(csnPath, model) {
  if (!model)
    return null;
  // Copy because this function shift()s from the path.
  csnPath = [ ...csnPath ];
  const csnDictionaries = [
    'args', 'params', 'enum', 'mixin', 'elements', 'actions', 'definitions',
  ];
  const queryProps = [ 'from', 'where', 'groupBy', 'having', 'orderBy', 'limit', 'offset' ];

  let { query } = analyseCsnPath(
    csnPath,
    model
  );

  // remove definitions
  csnPath.shift();
  const artName = csnPath.shift();
  let currentThing = model.definitions[artName];
  let result = `${ (currentThing && currentThing.kind) ? currentThing.kind : 'artifact' }:${ _quoted(artName) }`;

  if (!currentThing)
    return result;

  if (query)
    query = queryDepth(currentThing.query, query);

  const elements = [];
  let inCsnDict = false;
  let inElement = false;
  let inAction = false;
  let inParam = false;
  let inKeys = false;
  let inRef = false;
  let inEnum = false;
  let inQuery = false;
  let inColumn = false;
  let inMixin = false;
  let inItems = false;

  // for top level actions
  if (currentThing.kind === 'action')
    inAction = true;
  for (const [ index, step ] of csnPath.entries()) {
    currentThing = currentThing[step];
    if (csnDictionaries.includes(step) && !inCsnDict) {
      inCsnDict = true;
      switch (step) {
        case 'elements':
          if (!inElement){
            inElement = true;
            // do not print intermediate items
            inItems = false;
          }
          break;
        case 'actions':
          inAction = true;
          break;
        case 'params':
          inParam = true;
          break;
        case 'enum':
          inElement = false;
          inEnum = true;
          break;
        case 'mixin':
          inMixin = true;
          inQuery = false;
          break;
        default:
          if (inElement) {
            // close element
            result += element();
            inElement = false;
          }
      }
    }
    else if ( inQuery ) {
      if (step === 'SELECT') {
        if (!csnPath[index + 1]) {
          result += select();
        }
        else if (queryProps.includes(csnPath[index + 1]) && !csnPath[index + 2]) {
          const clause = csnPath[index + 1];
          result += select();
          result += `/${ clause }`;
        }
      }
      else if (step === 'columns') {
        result += select();
        result += '/column';
        inColumn = true;
        inQuery = false;
      }
    }
    else if ( inMixin ) {
      if (step === 'on') {
        result += '/on';
        break;
      }
      else {
        result += selectAndMixin(step);
      }
    }
    else if (inEnum) {
      result += elementAndEnum(step);
    }
    else if (!inElement && step === 'query') {
      inQuery = true;
    }
    else if (inElement && step === 'keys') {
      // close element
      result += `${ element() }/key`;
      inElement = false;
      inKeys = true;
    }
    else if (inElement && step === 'on') {
      // close element
      result += `${ element() }/on`;
      inElement = false;
      break;
    }
    else if (inElement && step === 'items') {
      // this is an element called items
      if (csnPath[index - 1] === 'elements' && elements[elements.length - 1] !== 'elements') {
        elements.push(step);
      }
      else {
        inElement = false;
        inItems = true;
      }
    }
    else if (inElement && step === 'elements') {
      // this is an element called elements
      if (csnPath[index - 1] === 'elements')
        elements.push(step);
    }
    else if (inItems && step === 'elements') {
      inElement = true;
      inItems = false;
    }
    else if ( inKeys || inColumn) {
      if (typeof step === 'number') {
        if (currentThing.as)
          result += `:${ _quoted(currentThing.as) }`;
        else
          result += inRef ? `:${ _quoted(currentThing) }` : currentThing.ref ? `:${ _quoted(currentThing.ref.join('.')) }` : '';

        break;
      }
      if ( step === 'ref')
        inRef = true;
    }
    else if (inAction && step === 'returns') {
      result += `/${ step }`;
      break;
    }
    else if (inCsnDict) {
      if (inElement)
        elements.push(step);
      else if (inParam)
        result += param(step);

      else if (inAction)
        result += func(step);

      inCsnDict = false;
    }
  }
  if ( inItems )
    result += `${ element() }/items`;
  else if ( inElement )
    result += element();
  return result;

  function select() {
    let s = '/select';
    s += query.isOnlySelect ? '' : `:${ query.depth }`;
    return s;
  }
  function selectAndMixin(name) {
    return `${ select() }/mixin:${ _quoted(name) }`;
  }
  function element() {
    return `/element:${ _quoted(elements.join('.')) }`;
  }
  function param(name) {
    return `/param:${ _quoted(name) }`;
  }
  function func(name) {
    return `/function:${ _quoted(name) }`;
  }
  function elementAndEnum(name) {
    return `${ element() }/enum:${ _quoted(name) }`;
  }

  /**
   * Traverse rootQuery until targetQuery is found and count the depth,
   * check if targetQuery is only select in entity.
   */
  function queryDepth(rootQuery, targetQuery) {
    let targetQueryDepth = 1;
    let totalQueryDepth = 0;

    let isFound = false;
    traverseQuery(rootQuery, null, (q, querySelect) => {
      if ( querySelect )
        totalQueryDepth += 1;
      if ( querySelect && !isFound)
        targetQueryDepth += 1;
      if (q === targetQuery)
        isFound = true;
    });
    return { depth: targetQueryDepth, isOnlySelect: totalQueryDepth === 1 };
  }
}


function _quoted( name ) {
  return (name) ? `"${ name.replace( /"/g, '""' ) }"` : '<?>'; // sync ";
}


module.exports = {
  combinedLocation,
  emptyLocation,
  emptyWeakLocation,
  builtinLocation,
  normalizeLocation,
  dictLocation,
  constructSemanticLocationFromCsnPath,
};
