/**
 * Usage: Create an instance to process artifacts which should be checked for collision.
 * First call addArtifact to specify the current artifact,
 * then call addElement to register the elements of the current artifact.
 * Finally call the "done" function to check for duplicates.
 * In addition the internal structures will be reinitialized to enable reuse of the instance.
 */

'use strict';

const walker = require('../json/walker');

/**
 * database name - uppercase if not quoted
 *
 * @param {string} name Artifact name
 *
 * @returns {string} Name as it is present on the database
 */
function asDBName(name) {
  return (name[0] === '"')
    ? name
    : name.toUpperCase();
}

/**
 * Check for duplicate artifacts or elements
 *
 * @class DuplicateChecker
 */
class DuplicateChecker {
  constructor() {
    this.init();
  }

  /**
   * Initialize the state of the checker.
   */
  init() {
    this.seenArtifacts = {};
    this.currentArtifact = {};
  }

  /**
   * Add an artifact to the "seen"-list
   *
   * @param {string} name Rendered artifact name
   * @param {CSN.Location} location CSN location of the artifact
   * @param {string} modelName CSN artifact name
   */
  addArtifact( name, location, modelName ) {
    const dbName = asDBName(name);
    this.currentArtifact = {
      name, location, elements: {}, modelName,
    };
    if (!this.seenArtifacts[dbName])
      this.seenArtifacts[dbName] = [ this.currentArtifact ];
    else
      this.seenArtifacts[dbName].push(this.currentArtifact);
  }

  /**
   * Add an element to the "seen"-list
   *
   * @param {string} name Rendered element name
   * @param {CSN.Location} location
   * @param {string} modelName CSN element name
   *
   */
  addElement(name, location, modelName) {
    if (!this.currentArtifact.elements)
      return;
    const dbName = asDBName(name);
    const currentElements = this.currentArtifact.elements;
    const element = { name, location, modelName };
    if (!currentElements[dbName])
      currentElements[dbName] = [ element ];
    else
      currentElements[dbName].push(element);
  }

  /**
   * No more artifacts need to be processed, check for duplicates and re-init the object.
   *
   * @param {Function} error Function of makeMessageFunction()
   * @param {CSN.Options} options Options used for the compilation
   */
  check(error, options = null) {
    walker.forEach(this.seenArtifacts, (artifactName, artifacts) => {
      if (artifacts.length > 1) {
        artifacts.forEach((artifact) => { // report all colliding artifacts
          const collidesWith = this.seenArtifacts[artifactName].find( art => art !== artifact );
          let namingMode;
          if (options)
            namingMode = options.toHana ? options.toHana.names : options.toSql.names;
          else
            namingMode = 'plain';

          error(null, [ 'definitions', artifact.modelName ],
                { name: collidesWith.modelName, prop: namingMode },
                'Artifact name containing dots can\'t be mapped to a SQL compliant identifier in naming mode $(PROP) because it conflicts with existing definition $(NAME)');
        });
      }
      artifacts.forEach((artifact) => {
        walker.forEach(artifact.elements, (elementName, elements) => {
          if (elements.length > 1) {
            elements.forEach((element) => { // report all colliding elements
              error(null, [ 'definitions', artifact.modelName, 'elements', element.modelName ],
                    `Duplicated element '${element.name}' in artifact '${artifact.name}'`);
            });
          }
        });
      });
    });
    // clean internal structures
    this.init();
  }
}

module.exports = DuplicateChecker;
