const cds = require('../../cds')
const { UPDATE, INSERT, DELETE } = cds.ql

const { ensureNoDraftsSuffix, ensureDraftsSuffix } = require('../utils/handler')
const { readAndDeleteKeywords, isActiveEntityRequested } = require('../utils/where')
const draftCompositionTree = require('../utils/compositionTree')
const { isDraftRootEntity } = require('../../cds-services/services/utils/compositionTree')
const { getVirtuals, postProcessVirtuals } = require('../../db/generic/virtual')

const _getDeleteDraftAdminCqn = draftUUID =>
  DELETE.from('DRAFT.DraftAdministrativeData').where([{ ref: ['DraftUUID'] }, '=', { val: draftUUID }])

const _getDeleteRootDraftCqn = (targetName, rootWhere) => DELETE.from(targetName).where(rootWhere)

/**
 * Generic Handler for draftActivate requests.
 * In case of success it triggers an 'UPDATE' or 'CREATE' event.
 *
 * @param req
 */
const _handler = async function (req) {
  if (
    isActiveEntityRequested(req.query.SELECT.from.ref[0].where || []) ||
    req.query.SELECT.from.ref.length > 2 ||
    !isDraftRootEntity(this.model.definitions, ensureNoDraftsSuffix(req.target.name))
  ) {
    req.reject(400)
  }

  const { draftData, activeData, adminData } = await draftCompositionTree(this, req)

  if (!draftData) req.reject(404)
  if (adminData.InProcessByUser !== req.user.id) req.reject(403, 'DRAFT_LOCKED_BY_ANOTHER_USER')

  /*
   * create or update
   */
  let query, event
  if (activeData) {
    readAndDeleteKeywords(['IsActiveEntity'], req.query.SELECT.from.ref[0].where)
    event = 'UPDATE'
    // REVSIIT: setting data should be part of ql
    query = UPDATE(req.target).where(req.query.SELECT.from.ref[0].where)
    query.UPDATE.data = draftData
    query._activeData = activeData
  } else {
    event = 'CREATE'
    query = INSERT.into(req.target).entries(draftData)
  }

  // REVISIT: _draftMetadata
  const r = new cds.Request({ event, query, data: draftData, _draftMetadata: adminData })

  // REVISIT: should not be necessary
  r._ = Object.assign(r._, req._)
  r.getUriInfo = () => req.getUriInfo()
  r.getUrlObject = () => req.getUrlObject()
  r._.params = req.params

  const virtuals = getVirtuals(req, this.model)
  // use finally to preserve r.messages in success or error case
  let result
  try {
    result = await this.dispatch(r)
    postProcessVirtuals(virtuals, result)
  } finally {
    // REVISIT: should not be necessary
    if (r.messages) for (const m of r.messages) req.info(m)
  }

  /*
   * delete draft data
   */
  const deleteDraftAdminCqn = _getDeleteDraftAdminCqn(adminData.DraftUUID)
  const deleteRootDraftCqn = _getDeleteRootDraftCqn(
    ensureDraftsSuffix(req.target.name),
    req.query.SELECT.from.ref[0].where
  )
  await cds.db.tx(req).run([deleteDraftAdminCqn, deleteRootDraftCqn])

  return result
}

// REVISIT: draftActivate -> ACTIVATE

const { ODATA, COMMON } = require('../../common/constants/annotation')
const _relevant = e => e[ODATA.DRAFT] || e[COMMON.DRAFT_NODE.PREP_ACTION]

module.exports = function () {
  for (const entity of Object.values(this.entities).filter(_relevant)) {
    this.on('draftActivate', entity, _handler)
  }
}
