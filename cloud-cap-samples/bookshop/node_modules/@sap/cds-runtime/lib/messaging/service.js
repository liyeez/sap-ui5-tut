const cds = require('../cds')

const _isDeclared = event => typeof event === 'object' && event.kind === 'event'
const _srvNameOfEvent = declared => declared._service.name
// @source on service level already has some other meaning
const _sourceOfEvent = declared => declared['@source'] || (declared._service && declared._service['@event.source'])

class MessagingService extends cds.Service {
  init() {
    // Only for one central `messaging` service, otherwise all technical services would register themselves
    if (this.name === 'messaging') {
      // listen for all subscriptions to declared events of remote, i.e. connected services
      cds.on('subscribe', (srv, event) => {
        const declared = srv.events[event]
        if (declared && srv.name in cds.requires && !srv.mocked) {
          // we register self-handlers for declared events, which are supposed
          // to be calles by subclasses calling this.dispatch on incoming events
          this.on(declared.name, async (msg, next) => {
            const { data, headers } = msg
            await srv.tx(msg).emit({ event, data, headers, __proto__: msg })
            return next()
          })
        }
        // const declared = srv.events[event]
      })

      // forward all emits for all declared events of local, i.e. served services

      cds.on('serving', srv => {
        for (const declared of srv.events) {
          const event = declared.name.slice(srv.name.length + 1)
          // calls to srv.emit are forwarded to this.emit, which is expected to
          // be overriden by subclasses to write events to message channel
          srv.on(event, async (msg, next) => {
            const { data, headers } = msg
            await this.tx(msg).emit({ event: declared.name, data, headers })
            return next()
          })
        }
      })
    }

    // if outbox is switched on, decorate the emit method to actually do
    // the emit only when the request succeeded
    if (this.options.outbox) {
      const { emit } = this
      this.emit = function (...args) {
        // `this` is a srv.tx
        if (this.context) return this.context.on('succeeded', () => emit.call(this, ...args))
        return emit.call(this, ...args)
      }
    }

    const { on } = this
    this.on = function (...args) {
      if (Array.isArray(args[0])) {
        const [topics, ...rest] = args
        return topics.map(t => on.call(this, t, ...rest))
      }
      return on.call(this, ...args)
    }
  }

  emit(event, data, headers) {
    return super.emit(event instanceof cds.Event ? event : new cds.Event(this.message4(event, data, headers)))
  }

  on(event, handler) {
    if (_isDeclared(event)) {
      return super.on(event.name, handler)
    }
    return super.on(event, handler)
  }

  topic4(event, inbound) {
    const declared =
      typeof event === 'object' ? event : cds.model && cds.model.definitions && cds.model.definitions[event]
    if (!declared) return
    return this.topic(declared, inbound) || declared.name
  }

  event4(topic, inbound) {
    // REVISIT: Get model of context instead
    const definitions = cds.model && cds.model.definitions
    if (!definitions) return
    for (const definitionName of Object.keys(definitions)) {
      const definition = definitions[definitionName]
      if (
        definition.kind !== 'event' ||
        (inbound && !(_srvNameOfEvent(definition) in cds.requires)) ||
        (!inbound && _srvNameOfEvent(definition) in cds.requires)
      )
        continue
      const _topic = this.topic4(definition, inbound)
      if (_topic === topic) return definitionName
    }
  }

  normalize(topicOrEvent, inbound) {
    if (typeof topicOrEvent === 'object' && topicOrEvent.kind === 'event') {
      return [this.topic4(topicOrEvent, inbound), topicOrEvent.name]
    }
    let topic
    let event
    const _topic = this.topic4(topicOrEvent, inbound)
    if (_topic) {
      // must have been event
      topic = _topic
      event = topicOrEvent
    } else {
      // must have been topic
      topic = topicOrEvent
      const _event = this.event4(topicOrEvent, inbound)
      if (_event) event = _event
    }
    return [topic, event]
  }

  topic(declared, inbound) {
    const topic = declared['@topic']
    if (topic) return topic

    const source = _sourceOfEvent(declared) || this.defaultSource(inbound)
    const type = declared['@type']
    if (!type) return // use default fallback
    const typeN = type.replace(/\./g, '/')
    let sourceN = source.replace(/^\//, '')
    if (sourceN.split('/').length === 2) sourceN = sourceN + '/-'
    return `${sourceN}/ce/${typeN}`
  }

  defaultSource(inbound) {
    return '/default/sap/cap'
  }

  headers(declared) {
    const result = {}
    const source = _sourceOfEvent(declared) || this.defaultSource(false)
    const type = declared['@type']
    if (type) {
      result.type = type
      result.source = source
      result.specversion = '1.0'
      result.time = new Date(Date.now()).toISOString()
      result.datacontenttype = 'application/json'
    }
    return result
  }

  /**
   * Subclasses can use this method to create events
   *
   * @param event
   * @param data
   * @param headers
   */
  message4(event, data, headers) {
    let declared
    if (_isDeclared(event)) {
      declared = event
      event = event.name
    }
    const msg = typeof event === 'object' ? event : { event, data, headers: { ...headers } }
    if (_isDeclared(msg.event)) {
      declared = msg.event
      msg.event = msg.event.name
    }
    if (!msg.headers) msg.headers = {}
    if (!msg.inbound) {
      declared = declared || (cds.model && cds.model.definitions[msg.event]) || this.event4(msg.event, false)
      if (!msg.headers.id) msg.headers.id = cds.utils.uuid()
      if (declared) msg.headers = { ...this.headers(declared), ...msg.headers }
    }
    return msg
  }
}

module.exports = MessagingService
