const cds = require('../cds')
const LOG = cds.log('messaging')
const MessagingService = require('./service')
const { queueName } = require('./common-utils/naming-conventions')
const optionsApp = require('../common/utils/vcap.js')
const queued = require('./common-utils/queued')

// We could have used placeholders '+/+/+' for the first three segments
const _wildcarded = topic => topic.replace(/.*?\/.*?\/.*?\//, '+/+/+/')

class AMQPWebhookMessaging extends MessagingService {
  async init() {
    // stores also event information
    this.subscribedTopics = new Map()
    this.optionsApp = optionsApp
    if (this.options.queue) {
      const queueConfig = { ...this.options.queue }
      delete queueConfig.name
      if (Object.keys(queueConfig).length) this.queueConfig = queueConfig
    }
    this.queueName = queueName(this.options, this.optionsApp)
    // enables queued async operations (without awaiting)
    this.queued = queued()

    cds.once('served', () => {
      this.ready = true
      this.onServed()
    })

    cds.once('listening', () => {
      this.onListening()
    })

    return super.init()
  }

  async emit(event, ...etc) {
    const msg = this.message4(event, ...etc)
    msg.event = this.topic4(msg.event, false) || msg.event
    const client = this.getClient()
    await this.queued(() => {})()
    return client.emit(msg)
  }

  // inbound -> listen to channel (once)
  on(topicOrEvent, handler) {
    const [topic, event] = this.normalize(topicOrEvent, true)
    this.subscribedTopics.set(topic, event || topic)
    return super.on(event || topic, handler)
  }

  onServed() {
    if (this.subscribedTopics.size) {
      const management = this.getManagement()
      this.queued(management.createQueueAndSubscriptions.bind(management))()
      this.queued(this.listenToClient.bind(this))(async (_topic, _payload, _other, { done, failed }) => {
        const event = this.subscribedTopics.get(_topic) || this.subscribedTopics.get(_wildcarded(_topic))

        const data = _payload.data
        const headers = { ..._payload }
        delete headers.data
        try {
          await super.emit({
            event,
            data,
            headers,
            inbound: true,
            ...(_other || {})
          })
          done()
        } catch (e) {
          failed()
          LOG._error && LOG.error(e)
        }
      })
    }
  }

  onListening() {}

  defaultSource(inbound) {
    return inbound ? '+/+/+' : (this.options.credentials && this.options.credentials.namespace) || super.defaultSource()
  }

  listenToClient(cb) {
    return this.getClient().listen(cb)
  }
}

module.exports = AMQPWebhookMessaging
