const cds = require('../cds')
const { createCqlString } = require('../cds-services/adapter/rest/rest-to-cqn/utils')
// REVISIT: should be cds.ql
const { SELECT } = require('../cds-services/statements')

const { getMaxPageSize } = require('../common/utils/page')

/*
 * uses new odata2cqn
 */
const _newReadToCQN = ({ isCollection, segments }, target, req) => {
  const odata = !!req.getUrlObject

  const url = odata ? decodeURI(req.getUrlObject().path) : decodeURI(req.url)

  const parsed = cds.odata.parse.url(url)

  // TODO: compound keys
  const key = Object.keys(target.keys)[0]
  let keyValue
  if (odata) {
    segments = req.getUriInfo().getPathSegments()
    // TODO: use const from okra?
    isCollection = segments[segments.length - 1].getKind() === 'ENTITY.COLLECTION'
    keyValue =
      segments[0].getKeyPredicates && segments[0].getKeyPredicates()[0] && segments[0].getKeyPredicates()[0].getText()
  } else {
    keyValue = segments[1]
  }

  const cqn = SELECT.from(createCqlString(target, key, keyValue))

  parsed.SELECT.from.ref[0] = cqn.SELECT.from.ref[0]

  cqn.SELECT.from = parsed.SELECT.from
  cqn.SELECT.columns = parsed.SELECT.columns
  cqn.SELECT.search = parsed.SELECT.search
  cqn.SELECT.where = parsed.SELECT.where
  cqn.SELECT.orderBy = parsed.SELECT.orderBy
  cqn.SELECT.groupBy = parsed.SELECT.groupBy
  cqn.SELECT.count = parsed.SELECT.count

  if (!isCollection) cqn.SELECT.one = true

  if (isCollection && parsed.SELECT.limit) {
    // adjust SELECT.limit based on @cds.query.limit annotations
    const rows = parsed.SELECT.limit.rows ? parsed.SELECT.limit.rows.val : Number.MAX_SAFE_INTEGER
    const offset = parsed.SELECT.limit.offset ? parsed.SELECT.limit.offset.val : 0
    cqn.limit(Math.min(rows, getMaxPageSize(target)), offset)
  }

  return cqn
}

module.exports = { _newReadToCQN }
