// needs to be more sophisticated, e. g. odata v2/v4 and resolving "author/id"
const formatVal = (val, element, target, getSafeNumber) => {
  if (val === null || val === 'null') return 'null'
  const csnElement = (target && target.elements && target.elements[element]) || { type: undefined }
  switch (csnElement.type) {
    case 'cds.String':
    case 'cds.LargeString':
      return `'${val}'`
    case 'cds.DateTime':
    case 'cds.Date':
    case 'cds.Timestamp':
      return process.env.T19 ? `'${val}'` : val // TODO: improve
    default:
      return (isNaN(val) && `'${val}'`) || (getSafeNumber && getSafeNumber(val)) || val
  }
}

// only supported structures are [ref, =, val] or [val]
const _isValidWhereConditionRest = where => {
  if (where.length === 1) return 'val' in where[0]
  return where.length === 3 && where[0].ref && where[1] === '=' && 'val' in where[2]
}

const _generateRestKeyPath = where => {
  if (!_isValidWhereConditionRest(where)) {
    throw new Error("Feature not supported: complex where of fluent API (not in format 'a = 1')")
  }

  return (where.length === 1 && where[0].val) || where[2].val
}

const _isValidWhereConditionOdata = where => {
  for (let i = 0; i < where.length; i++) {
    if ((i === 0 || where[i - 1] === 'and') && where[i].ref) continue
    if (where.length === 1 && 'val' in where[i]) continue
    if (where[i - 1].ref && where[i] === '=') continue
    if (where[i - 1] === '=' && 'val' in where[i]) continue
    if ('val' in where[i - 1] && where[i] === 'and') continue
    return false
  }

  return true
}

// only supported structure is alternating ref, =, val combined with and
const _generateOdataKeyPath = (where, target) => {
  // remove brackets
  const whereNoBrackets = where.filter(e => e !== '(' && e !== ')')

  if (!_isValidWhereConditionOdata(whereNoBrackets)) {
    throw new Error("Feature not supported: complex where of fluent API (not in format 'a = 1')")
  }

  const keyPath = where.map((e, i) => {
    if (typeof e === 'string') {
      if (e === '=') return e
      if (e === 'and') return ','
    }
    if (typeof e === 'object') {
      if (e.ref) return e.ref[e.ref.length - 1]
      if ('val' in e) {
        const previousRef = (where[i - 2] && where[i - 2].ref) || []
        return formatVal(e.val, previousRef[previousRef.length - 1], target)
      }
    }
  })

  return `(${keyPath.join('')})`
}

const generateKeysOfWhere = (where, type, target) => {
  if (type === 'rest') return _generateRestKeyPath(where)
  // odata v2 and v4
  return _generateOdataKeyPath(where, target)
}

const splitByAndGetValueByIndex = (value, split = '.', offset = 0) => {
  const parts = value.split(split)
  return parts[parts.length - 1 - offset]
}

const generateKeyPath = (from, type, transitions) => {
  if (typeof from === 'string') return { path: from }
  return {
    path: from.ref
      .map((f, i) => {
        if (f.id) {
          let keyPath = generateKeysOfWhere(f.where, type, transitions && transitions[i].target)
          if (type === 'rest') keyPath = `/${keyPath}`
          return `${f.id}${keyPath}`
        }
        return f
      })
      .join('/')
  }
}

module.exports = {
  formatVal,
  generateKeyPath,
  generateKeysOfWhere,
  splitByAndGetValueByIndex
}
