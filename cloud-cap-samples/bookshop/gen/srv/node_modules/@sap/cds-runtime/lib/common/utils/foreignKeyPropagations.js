const cds = require('../../cds')

const _generateParentField = (foreignKeyPropagations, row) => {
  if (
    foreignKeyPropagations.parentFieldName &&
    !row[foreignKeyPropagations.parentFieldName] &&
    foreignKeyPropagations.autoGenerate
  ) {
    row[foreignKeyPropagations.parentFieldName] = cds.utils.uuid()
  }
}

const _generateChildField = (foreignKeyPropagations, childRow) => {
  if (!childRow[foreignKeyPropagations.childFieldName] && foreignKeyPropagations.autoGenerate) {
    childRow[foreignKeyPropagations.childFieldName] = cds.utils.uuid()
  }
}

const _propagateToChid = (foreignKeyPropagation, row, childRow) => {
  if (foreignKeyPropagation.parentFieldName) {
    childRow[foreignKeyPropagation.childFieldName] = row[foreignKeyPropagation.parentFieldName]
  } else if (foreignKeyPropagation.parentFieldValue !== undefined)
    childRow[foreignKeyPropagation.childFieldName] = foreignKeyPropagation.parentFieldValue
}

const _propagateToParent = (foreignKeyPropagations, childRow, row) => {
  row[foreignKeyPropagations.parentFieldName] = childRow[foreignKeyPropagations.childFieldName]
}

const propagateForeignKeys = (tKey, row, foreignKeyPropagations) => {
  const childRows = Array.isArray(row[tKey]) ? row[tKey] : [row[tKey]]
  for (const childRow of childRows) {
    if (!childRow) return
    for (const foreignKeyPropagation of foreignKeyPropagations) {
      if (foreignKeyPropagation.fillChild) {
        _generateParentField(foreignKeyPropagation, row)
        _propagateToChid(foreignKeyPropagation, row, childRow)
      } else {
        _generateChildField(foreignKeyPropagation, childRow)
        _propagateToParent(foreignKeyPropagation, childRow, row)
      }
    }
  }
}

const _getSubOns = on => {
  // this only works for on conds with `and`, once we support `or` this needs to be adjusted
  const newOn = on.filter(e => e !== '(' && e !== ')')
  const subOns = []
  let currArr = []
  for (const onEl of newOn) {
    if (currArr.length === 0) subOns.push(currArr)
    if (onEl !== 'and') currArr.push(onEl)
    else {
      currArr = []
    }
  }
  for (const subOn of subOns) {
    // We don't support anything else than
    // A = B AND C = D AND ...
    if (subOn.length !== 3) return []
  }
  return subOns
}

const _autoGenerate = el => el && el.type === 'cds.UUID' && el.key

const _parentFieldsFromSimpleOnCond = (element, subOn, skipForbiddenViewCheck) => {
  const idxChildField = subOn.findIndex(o => o.ref && o.ref[0] === element.name)
  if (idxChildField === -1) return
  let childFieldName = subOn[idxChildField].ref && subOn[idxChildField].ref[1]
  const childElement = element._target.elements[childFieldName]
  const idxParentField = idxChildField === 2 ? 0 : 2
  if (subOn[1] !== '=') return
  let parentRef = subOn[idxParentField].ref

  if (parentRef && parentRef.length > 1) {
    parentRef = [parentRef.join('.').replace(`${element.name}.`, '')]
    childFieldName = subOn[idxChildField].ref && subOn[idxChildField].ref.join('.').replace(`${element.name}.`, '')
  }

  if (!childElement) {
    // update on view with key in parent

    return [
      {
        fillChild: false,
        childFieldName,
        parentFieldName: parentRef[0],
        autoGenerate: _autoGenerate(element.parent.elements[parentRef[0]])
      }
    ]
  }

  if (!childElement.on && parentRef && parentRef.length === 1) {
    return _foreignKeyPropagationsFromToManyOn(element, parentRef, childFieldName, skipForbiddenViewCheck)
  }
  if ('val' in subOn[idxParentField]) {
    return _foreignKeyPropagationsFromStaticOn(childFieldName, idxParentField, subOn)
  }
  if (childElement._isAssociationStrict && childElement.on) {
    return _foreignKeyPropagationsFromCustomBacklink(element, childElement)
  }
}

const _foreignKeyPropagationsFromStaticOn = (childFieldName, idxParentField, subOn) => {
  if (childFieldName) {
    return [{ fillChild: true, parentFieldValue: subOn[idxParentField].val, childFieldName }]
  }
}

const _foreignKeyPropagationsFromToManyOn = (element, parentRef, childFieldName, skipForbiddenViewCheck) => {
  const parentFieldName = parentRef[0]
  if (parentFieldName === '$self') {
    const foreignKeys = _foreignKeysForTarget(element, childFieldName)
    if (foreignKeys) {
      const parentKeys = _parentKeys(element)

      return resolvedKeys(parentKeys, foreignKeys, true)
    }

    return []
  }

  return [
    {
      fillChild: true,
      childFieldName,
      parentFieldName,
      autoGenerate: _autoGenerate(element.parent.elements[parentFieldName])
    }
  ]
}

const _foreignKeyPropagationsFromCustomBacklink = (element, childElement) => {
  const foreignKeyPropagations = []
  const subOns = _getSubOns(childElement.on)
  for (const subOn of subOns) {
    if (subOn[1] === '=') {
      const parentFieldIdx = subOn.findIndex(o => o.ref && o.ref[0] === childElement.name)
      const otherFieldIdx = parentFieldIdx === 0 ? 2 : 0
      const otherField = subOn[otherFieldIdx]
      if (otherField.ref && otherField.ref.length === 1) {
        const parentFieldName = subOn[parentFieldIdx].ref[1]
        foreignKeyPropagations.push({
          fillChild: true,
          parentFieldName,
          childFieldName: otherField.ref[0],
          autoGenerate: _autoGenerate(element.parent.elements[parentFieldName])
        })
      } else if (otherField.val !== undefined) {
        const parentFieldName = subOn[parentFieldIdx] && subOn[parentFieldIdx].ref[1]
        const parentField = subOn[otherFieldIdx === 2 ? 0 : 2]
        foreignKeyPropagations.push({
          fillChild: true,
          parentFieldName,
          parentFieldValue: parentField.val,
          childFieldValue: otherField.val
        })
      }
    }
  }
  return foreignKeyPropagations
}

const _foreignKeyPropagationsFromOn = (element, on, skipForbiddenViewCheck) => {
  const subOns = _getSubOns(on)

  const foreignKeyPropagations = []
  for (const subOn of subOns) {
    const subParentFields = _parentFieldsFromSimpleOnCond(element, subOn, skipForbiddenViewCheck)
    if (subParentFields) foreignKeyPropagations.push(...subParentFields)
  }
  return foreignKeyPropagations
}

const resolvedKeys = (foreignKeys, targetKeys, fillChild) => {
  const foreignKeyPropagations = []
  for (let i = 0; i < foreignKeys.length; i++) {
    foreignKeyPropagations.push({
      fillChild,
      childFieldName: targetKeys[i].name,
      autoGenerate: _autoGenerate(targetKeys[i]),
      parentFieldName: foreignKeys[i].name
    })
  }

  return foreignKeyPropagations.length && foreignKeyPropagations
}

const foreignKeyPropagations = (element, skipForbiddenViewCheck, resolveView = true) => {
  if (element.is2many && element.on) {
    const foreignKeyPropagations = _foreignKeyPropagationsFromOn(element, element.on, skipForbiddenViewCheck)
    return foreignKeyPropagations.length && foreignKeyPropagations
  }

  if (element.is2one) {
    if (!element.on) {
      const foreignKeys = _foreignKeys(element)
      if (foreignKeys) {
        const targetKeys = _targetKeys(element)
        return resolvedKeys(foreignKeys, targetKeys)
      }

      return []
    } else {
      // It's a link through a backlink
      const foreignKeyPropagations = _foreignKeyPropagationsFromOn(element, element.on, skipForbiddenViewCheck)
      return foreignKeyPropagations.length && foreignKeyPropagations
    }
  }
}

const _foreignKeys = csnElement => {
  return Object.values(csnElement.parent.elements).filter(element => element['@odata.foreignKey4'] === csnElement.name)
}

const _foreignKeysForTarget = (csnElement, name) => {
  return Object.values(csnElement._target.elements).filter(
    element =>
      !element.isAssociation && !element.isComposition && element['@odata.foreignKey4'] === (name || csnElement.name)
  )
}

const _targetKeys = csnElement => {
  return Object.values(csnElement._target.keys).filter(
    element => !element.isAssociation && !element.isComposition && element.name !== 'IsActiveEntity'
  )
}

const _parentKeys = csnElement => {
  return Object.values(csnElement.parent.keys).filter(
    element => !element.isAssociation && !element.isComposition && element.name !== 'IsActiveEntity'
  )
}

const _structPrefix = csnElement => {
  if (csnElement.parent && csnElement.parent._isStructured) {
    const prefix = _structPrefix(csnElement.parent)
    if (!prefix) return csnElement.parent.name + '_'
    return prefix + csnElement.parent.name + '_'
  }

  return ''
}

module.exports = {
  foreignKeyPropagations,
  propagateForeignKeys,
  _foreignKeys,
  _targetKeys,
  _structPrefix
}
