const OPERATORS = {
  '=': 'eq',
  '!=': 'ne',
  '<': 'lt',
  '>': 'gt',
  '<=': 'le',
  '>=': 'ge'
}
let getSafeNumber

const needArrayProps = Object.fromEntries(
  ['where', 'search', 'xpr', 'columns', 'expand', 'orderBy', 'ref', 'args'].map(propName => [
    propName,
    cur => Array.isArray(cur) && (cur.length !== 0 || propName === 'expand')
  ])
)

const validators = {
  SELECT: SELECT => SELECT && SELECT.from,
  INSERT: INSERT => {
    if (INSERT.rows || INSERT.values) {
      throw new Error('Feature not supported: INSERT statement with .values or .rows')
    }
    return INSERT && INSERT.into
  },
  UPDATE: UPDATE => UPDATE && UPDATE.entity,
  DELETE: DELETE => DELETE && DELETE.from,
  from: any => (typeof any === 'string' && any) || any.ref,
  into: any => (typeof any === 'string' && any) || any.ref,
  entity: any => (typeof any === 'string' && any) || any.ref,
  id: id => typeof id === 'string',
  val: val => typeof val === 'string' || typeof val === 'number' || val === null,
  count: count => typeof count === 'boolean',
  limit: limit => limit && (limit.rows || limit.offset),
  rows: rows => rows && rows.val && typeof rows.val === 'number',
  offset: offset => offset && offset.val && typeof offset.val === 'number',
  sort: sort => sort === 'asc' || sort === 'desc',
  func: func => typeof func === 'string',
  one: count => typeof count === 'boolean',
  as: any => typeof any === 'string',
  ...needArrayProps
}

// strip service & namespace prefixes
const _entityUrl = path => path.match(/^(\w*\.)*(.*)$/)[2]

const _formatVal = val => {
  if (val === null || val === 'null') return 'null'
  if (typeof val !== 'number') return `'${val}'`
  return getSafeNumber(val)
}

function getProp(obj, propName) {
  const validate = validators[propName]
  const isValid = validate && validate(obj[propName])
  if (isValid) {
    return obj[propName]
  }
  throw new Error(`Invalid property '${propName}' provided`)
}

function hasValidProps(obj, ...names) {
  for (const propName of names) {
    const validate = validators[propName]
    const isValid = validate && validate(obj[propName])
    if (!isValid) {
      return false
    }
  }
  return true
}

function _args(args) {
  const res = []

  for (const cur of args) {
    if (typeof cur === 'string') {
      res.push(cur)
      continue
    }
    if (hasValidProps(cur, 'func', 'args')) {
      res.push(`${cur.func}(${_args(cur.args)})`)
    }
    if (hasValidProps(cur, 'ref')) {
      res.push(cur.ref.join('/'))
    }
    if (hasValidProps(cur, 'val')) {
      res.push(_formatVal(cur.val))
    }
  }
  return res.join(',')
}

function _xpr(expr) {
  const res = []

  for (const cur of expr) {
    if (typeof cur === 'string') {
      // REVISIT: will it be fixed with a new odata2cqn and follow-ups?
      const isOrIsNotValue = cur.match(/^is\s(not)?\s*(.+)$/)
      if (isOrIsNotValue) {
        const operator = isOrIsNotValue[1] /* 'is not' */ ? 'ne' : 'eq'
        res.push(...[operator, _formatVal(isOrIsNotValue[2])])
      } else {
        res.push(OPERATORS[cur] || cur.toLowerCase())
      }
      continue
    }
    if (hasValidProps(cur, 'ref')) {
      res.push(cur.ref.join('/'))
    }
    if (hasValidProps(cur, 'val')) {
      res.push(_formatVal(cur.val))
    }
    if (hasValidProps(cur, 'xpr')) {
      res.push('(' + _xpr(cur.xpr) + ')')
    }
    if (hasValidProps(cur, 'func', 'args')) {
      res.push(`${cur.func}(${_args(cur.args)})`)
    }
  }
  return res.join(' ')
}

const _keysOfWhere = (where, kind) => {
  if (!Array.isArray(where) || !where.length) return ''
  const keys =
    kind === 'rest'
      ? where.length === 1
        ? getProp(where[0], 'val')
        : getProp(where[2], 'val')
      : where
          .map(cur => {
            if (hasValidProps(cur, 'ref')) return cur.ref.join('/')
            if (hasValidProps(cur, 'val')) return _formatVal(cur.val)
            if (cur === 'and') return ','
            return cur
          })
          .join('')
  return kind === 'rest' ? `/${keys}` : `(${keys})`
}

function _from(from, kind) {
  if (typeof from === 'string') return _entityUrl(from)

  let ref = getProp(from, 'ref')
  ref = (Array.isArray(ref) && ref) || [ref]

  const path = []
  for (const curRef of ref) {
    if (hasValidProps(curRef, 'where', 'id')) {
      const { where, id } = curRef
      const keys = _keysOfWhere(where, kind)
      path.push(`${id}${keys}`)
    } else if (typeof curRef === 'string') {
      path.push(curRef)
    }
  }
  return _entityUrl(path.join('/'))
}

function $select(columns, separator = '&') {
  let select = []
  const expand = []

  for (const col of columns) {
    if (hasValidProps(col, 'ref')) {
      let ref = col.ref.join('/')
      if (hasValidProps(col, 'expand')) {
        const curOptions = getOptions(col).join(';')
        ref += curOptions ? `(${curOptions})` : ''
        expand.push(ref)
        // REVISIT: expand to one & limit in options
        // > const expanded = $expand(col.expand)
        // > expand.push(expanded ? `${ref}(${expanded})` : ref)
        // see xtest('READ with expand'... in custom handler test
      } else {
        select.push(ref)
      }
    }
    if (col === '*') {
      select.push('*')
    }
  }
  // omit '$select' option if contains only '*'
  if (select.length === 1 && select[0] === '*') {
    select = []
  }

  const res = []
  if (expand.length) res.unshift('$expand=' + expand.join(','))
  if (select.length) res.unshift('$select=' + select.join(','))
  return res.join(separator)
}
const $expand = columns => $select(columns, ';')

function $count(count) {
  return `$count=${count}`
}

function $limit(limit) {
  const res = []
  if (hasValidProps(limit, 'rows')) {
    res.push('$top=' + getProp(limit.rows, 'val'))
  }
  if (hasValidProps(limit, 'offset')) {
    res.push('$skip=' + getProp(limit.offset, 'val'))
  }
  return res
}

function $orderBy(orderBy) {
  const res = []
  for (const cur of orderBy) {
    if (hasValidProps(cur, 'ref', 'sort')) {
      res.push(cur.ref + ' ' + cur.sort)
      continue
    }
    if (hasValidProps(cur, 'ref')) {
      res.push(cur.ref)
    }
  }
  return '$orderby=' + res.join(',')
}

function $search(search) {
  const res = []

  for (const cur of search) {
    if (hasValidProps(cur, 'xpr')) {
      res.push('(' + _xpr(cur.xpr) + ')')
    }
    if (hasValidProps(cur, 'val')) {
      res.push(_formatVal(cur.val))
    }
    if (hasValidProps(cur, 'ref')) {
      res.push(cur.ref)
    }
    if (typeof cur === 'string') {
      res.push(cur)
    }
  }
  return '$search=' + res.join(' ').replace('( ', '(').replace(' )', ')')
}

function $where(where) {
  return '$filter=' + _xpr(where)
}

function $one(one, url, kind) {
  return one && !_isOdataUrlWithKeys(url, kind) && '$top=1'
}

// eslint-disable-next-line no-useless-escape
const _isOdataUrlWithKeys = (url, kind) => kind !== 'rest' && /^[\w\.]+\(.*\)/.test(url)

const parsers = {
  columns: (cqnPart, url, kind) => $select(cqnPart),
  expand: (cqnPart, url, kind) => $expand(cqnPart),
  where: (cqnPart, url, kind) => $where(cqnPart),
  search: (cqnPart, url, kind) => $search(cqnPart),
  orderBy: cqnPart => $orderBy(cqnPart),
  count: (cqnPart, url, kind) => $count(cqnPart, url, kind),
  limit: cqnPart => $limit(cqnPart),
  one: (cqnPart, url, kind) => $one(cqnPart, url, kind)
}

function getOptions(cqnPart, url, kind) {
  const options = []
  for (const opt in cqnPart) {
    if (cqnPart[opt] === undefined) continue
    if (!hasValidProps(cqnPart, opt)) throw new Error(`Feature not supported: SELECT statement with .${opt}`)
    const parsed = parsers[opt] && parsers[opt](cqnPart[opt], url, kind)
    const parsedOpts = (Array.isArray(parsed) && parsed) || (parsed && [parsed]) || []
    options.push(...parsedOpts)
  }
  return options
}

const _select = (cqn, kind) => {
  const SELECT = getProp(cqn, 'SELECT')
  const url = _from(getProp(SELECT, 'from'), kind)
  const queryOptions = getOptions(SELECT, url, kind).join('&')
  const path = queryOptions ? `${url}?${queryOptions}` : `${url}`
  return { method: 'GET', path }
}

const _insert = (cqn, kind) => {
  const INSERT = getProp(cqn, 'INSERT')
  const path = _from(getProp(INSERT, 'into'), kind)
  const body = Array.isArray(INSERT.entries) && INSERT.entries.length === 1 ? INSERT.entries[0] : INSERT.entries
  return { method: 'POST', path, body }
}

const _copyData = data => {
  // only works on flat structures
  const copied = {}
  for (const property in data) {
    copied[property] =
      typeof data[property] === 'object' && 'val' in data[property] ? data[property].val : data[property]
  }
  return copied
}

const _update = (cqn, kind) => {
  const UPDATE = getProp(cqn, 'UPDATE')
  const url = _from(getProp(UPDATE, 'entity'), kind)
  let keys = ''
  if (UPDATE.where) {
    if (_isOdataUrlWithKeys(url, kind)) {
      throw new Error('Cannot generate URL for UPDATE CQN. Conflicting .from and .where')
    }
    keys = _keysOfWhere(getProp(UPDATE, 'where'), kind)
  }
  // TODO: support for .set as well
  const body = _copyData(UPDATE.data)
  return { method: 'PATCH', path: `${url}${keys}`, body }
}

const _delete = (cqn, kind) => {
  const DELETE = getProp(cqn, 'DELETE')
  const url = _from(getProp(DELETE, 'from'), kind)
  let keys = ''
  if (DELETE.where) {
    if (_isOdataUrlWithKeys(url, kind)) {
      throw new Error('Cannot generate URL for DELETE CQN. Conflicting .from and .where')
    }
    keys = _keysOfWhere(getProp(DELETE, 'where'), kind)
  }
  return { method: 'DELETE', path: `${url}${keys}` }
}

function cqn2odata(cqn, kind, { safeNumber }) {
  getSafeNumber = safeNumber

  if (cqn.SELECT) return _select(cqn, kind)
  if (cqn.INSERT) return _insert(cqn, kind)
  if (cqn.UPDATE) return _update(cqn, kind)
  if (cqn.DELETE) return _delete(cqn, kind)

  throw new Error('Unknown CQN object cannot be translated to URL: ' + JSON.stringify(cqn))
}

module.exports = cqn2odata
